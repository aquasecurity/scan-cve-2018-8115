import requests
import logging
import sys
import json
import tarfile
import argparse
import shutil
import os.path

logging.basicConfig(format='%(message)s', level=logging.INFO)
logger = logging.getLogger('CVE-2018-8115')

REGISTRY_URL = 'https://registry.hub.docker.com'
REGISTRY_AUTH_URL = 'https://auth.docker.io'


class IncorrectImageName(Exception):
    pass


class ImageNotExists(Exception):
    pass


def get_auth(image):
    fetch_url = '{auth_url}/token?service=registry.docker.io&scope=repository:{image_name}:pull'.format(
        auth_url=REGISTRY_AUTH_URL, image_name=image)
    return requests.get(fetch_url).json().get('token')


def get_layers(image, auth_token):
    logger.info('Fetching %s metadata', image)
    results = []
    headers = {"Authorization": "Bearer {0}".format(auth_token)}
    try:

        blobs = requests.get(
            '{registry_url}/v2/{image}/manifests/latest'.format(registry_url=REGISTRY_URL, image=image),
            headers=headers).json()

    except json.decoder.JSONDecodeError:
        logging.error("Error - Incorrect image name")
        return []

    if not blobs.get('fsLayers'):
        logging.error("Error - Image is private or not exists")
        return []

    for single_hash in blobs.get('fsLayers'):
        results.append(single_hash.get('blobSum'))
    return list(set(results))


def download_layer(image, layer_hash, auth_token):
    layer_filename = layer_hash[layer_hash.find(':') + 1:]
    logger.info('Fetching Layer %s', layer_filename[:10])
    headers = {"Authorization": "Bearer {0}".format(auth_token)}
    r = requests.get('{registry_url}/v2/{image}/blobs/{layer_hash}'.format(registry_url=REGISTRY_URL, image=image,
                                                                           layer_hash=layer_hash), headers=headers,
                     stream=True)
    if r.status_code == 200:
        total_length = r.headers.get('content-length')
        with open(layer_filename, 'wb') as f:
            if total_length is None:
                r.raw.decode_content = True
                shutil.copyfileobj(r.raw, f)
            else:
                dl = 0
                total_length = int(total_length)
                for data in r.iter_content(chunk_size=4096):
                    dl += len(data)
                    f.write(data)
                    done = int(50 * dl / total_length)
                    sys.stdout.write("\r[%s%s] %d%%" % ('=' * done, ' ' * (50 - done), (dl / total_length * 100)))
                    sys.stdout.flush()
                sys.stdout.write("\n")

        return layer_filename
    return None


def is_layer_safe(layer_file):
    tar = tarfile.open(layer_file, mode='r:gz')
    while 1:
        next_block = tar.next()
        if not next_block:
            break

        if next_block.name.count('../'):
            file_path = next_block.name

            while file_path.find('//') > -1:
                file_path = file_path.replace('//', '/')

            while file_path.find('/./') > -1:
                file_path = file_path.replace('/./', '/')

            nested_count = file_path.count('../')

            while file_path.find('../') > -1:
                file_path = file_path.replace('../', '/')

            if file_path.count < nested_count:
                print("Virus")

        if next_block.linkname.count('../'):
            file_path = next_block.name

            while file_path.find('//') > -1:
                file_path = file_path.replace('//', '/')

            while file_path.find('/./') > -1:
                file_path = file_path.replace('/./', '/')

            nested_count = file_path.count('/')
            if nested_count < next_block.linkname.count('../'):
                print("Virus")


parser = argparse.ArgumentParser(description='CVE-2018-8115 vulnerability tester')
parser.add_argument('image', type=str, help='Registry image name. Ex. library/ubuntu')

args = parser.parse_args()
token = get_auth(args.image)
for single_layer in get_layers(args.image, token):
    layer = download_layer(args.image, single_layer, token)
    if layer:
        is_layer_safe(layer)
        os.remove(layer)

