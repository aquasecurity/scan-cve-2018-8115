import requests
import logging
import sys
import json
import tarfile
import argparse
import shutil
import os.path

MOTD = """
                               _____                      _ _         
     /\                       / ____|                    (_) |        
    /  \   __ _ _   _  __ _  | (___   ___  ___ _   _ _ __ _| |_ _   _ 
   / /\ \ / _` | | | |/ _` |  \___ \ / _ \/ __| | | | '__| | __| | | |
  / ____ \ (_| | |_| | (_| |  ____) |  __/ (__| |_| | |  | | |_| |_| |
 /_/    \_\__, |\__,_|\__,_| |_____/ \___|\___|\__,_|_|  |_|\__|\__, |
             | |                                                 __/ |
             |_|                                                |___/ 

Docker images verifier cli-tool (CVE-2018-8115)
To help the community stay safe, we at Aqua created an open source tool
that tests images for whether they are safe of this vulnerability.

Aqua Security
https://www.aquasec.com
"""

REGISTRY_URL = 'https://registry.hub.docker.com'
REGISTRY_AUTH_URL = 'https://auth.docker.io'

logging.basicConfig(format='%(message)s')
logger = logging.getLogger('CVE-2018-8115')
logger.setLevel(logging.INFO)


# REGISTRY_URL = 'http://127.0.0.1:5000'

def recursive_replace(data, pattern, replace):
    while data.find(pattern) > -1:
        data = data.replace(pattern, replace)
    return data


def generate_report(results):
    pass


def get_auth(image):
    fetch_url = '{auth_url}/token?service=registry.docker.io&scope=repository:{image_name}:pull'.format(
        auth_url=REGISTRY_AUTH_URL, image_name=image)
    return requests.get(fetch_url).json().get('token')


def get_layers(image, auth_token):
    logger.info('Fetching %s metadata', image)
    results = []
    headers = {"Authorization": "Bearer {0}".format(auth_token)}
    try:

        blobs = requests.get(
            '{registry_url}/v2/{image}/manifests/latest'.format(registry_url=REGISTRY_URL, image=image),
            headers=headers).json()

    except json.decoder.JSONDecodeError:
        logger.error("Error - Incorrect image name")
        return []

    if not blobs.get('fsLayers'):
        logger.error("Error - Image is private or not exists")
        return []

    for single_hash in blobs.get('fsLayers'):
        results.append(single_hash.get('blobSum'))
    return list(set(results))


def download_layer(image, layer_hash, auth_token):
    layer_filename = layer_hash[layer_hash.find(':') + 1:]
    logger.info('Fetching Layer %s', layer_filename[:10])
    headers = {"Authorization": "Bearer {0}".format(auth_token)}
    r = requests.get('{registry_url}/v2/{image}/blobs/{layer_hash}'.format(registry_url=REGISTRY_URL, image=image,
                                                                           layer_hash=layer_hash), headers=headers,
                     stream=True)
    if r.status_code == 200:
        total_length = r.headers.get('content-length')
        with open(layer_filename, 'wb') as f:
            if total_length is None:
                r.raw.decode_content = True
                shutil.copyfileobj(r.raw, f)
            else:
                dl = 0
                total_length = int(total_length)
                for data in r.iter_content(chunk_size=4096):
                    dl += len(data)
                    f.write(data)
                    done = int(50 * dl / total_length)
                    sys.stdout.write("\r[%s%s] %d%%" % ('=' * done, ' ' * (50 - done), (dl / total_length * 100)))
                    sys.stdout.flush()
                sys.stdout.write("\n")

        return layer_filename
    return None


def is_layer_safe(layer_file):
    results = []
    try:
        tar = tarfile.open(layer_file, mode='r:gz')
    except tarfile.ReadError:
        tar = tarfile.open(layer_file, mode='r')

    while True:
        next_block = tar.next()
        if not next_block:
            break

        filename = next_block.name
        link_destination = next_block.linkname

        if not os.path.relpath(filename).find('..\\') or not os.path.relpath(filename).find('../'):
            results.append((filename, 'file'))

        if link_destination:
            if link_destination[0] not in ['/', '\\']:
                full_path = os.path.dirname(filename) + "/" + link_destination
                if not os.path.relpath(full_path).find('..\\') or not os.path.relpath(full_path).find('../'):
                    results.append((full_path, 'link'))

    return results


logger.info(MOTD)
parser = argparse.ArgumentParser(description='')
parser.add_argument('--image', type=str, help='Registry image name. Ex. library/ubuntu')

args = parser.parse_args()
token = get_auth(args.image)
for single_layer in get_layers(args.image, token):
    layer = download_layer(args.image, single_layer, token)
    if layer:
        try:
            for malicious_file in is_layer_safe(layer):
                generate_report(malicious_file)
            os.remove(layer)
        except Exception as e:
            print(e)
